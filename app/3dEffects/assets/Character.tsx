import { useAnimations, useGLTF } from "@react-three/drei"
import React, { useEffect, useRef, useState } from "react"
import { useScrollDirection } from "react-use-scroll-direction"

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 public/character.glb -t -T
*/

import * as THREE from "three"
import { GLTF } from "three-stdlib"

type GLTFResult = GLTF & {
  nodes: {
    Cylinder003: THREE.SkinnedMesh
    Dustin: THREE.SkinnedMesh
    Bone: THREE.Bone
  }
  materials: {
    Dustin_Mat: THREE.MeshStandardMaterial
  }
}

type ActionName = "Clicked" | "Idle" | "Pull" | "Run"
type GLTFActions = Record<ActionName, THREE.AnimationAction>

export function Model(props: JSX.IntrinsicElements["group"]) {
  const [activeAnim, setActiveAnim] = useState("Idle")
  const group = useRef<THREE.Group>()
  const { nodes, materials, animations } = useGLTF(
    "/character-transformed.glb"
  ) as GLTFResult
  const { actions } = useAnimations<GLTFActions>(animations, group)

  const { isScrollingUp, isScrollingDown, scrollDirection } =
    useScrollDirection()

  // Fade between animations
  useEffect(() => {
    if (!actions[activeAnim]) return
    actions[activeAnim].reset().fadeIn(0.25).play()
    return () => {
      if (actions[activeAnim]) {
        actions[activeAnim].fadeOut(0.25)
      }
    }
  }, [activeAnim])

  // When click animation ends, go back to idle
  useEffect(() => {
    if (!actions[activeAnim]) return
    if (activeAnim == "Clicked") {
      let switchOnFinish = setTimeout(() => setActiveAnim("Idle"), 450)
      return () => {
        clearTimeout(switchOnFinish)
      }
    }
  }, [activeAnim])

  // Switch animations based on scroll
  useEffect(() => {
    if (!actions[activeAnim]) return
    let minAnimationDuration = setTimeout(() => {}, 1000)
    if (scrollDirection == "UP") {
      if (activeAnim != "Pull") setActiveAnim("Pull")
      clearTimeout(minAnimationDuration)
    } else if (scrollDirection == "DOWN") {
      if (activeAnim != "Run") setActiveAnim("Run")
      clearTimeout(minAnimationDuration)
    } else {
      if (activeAnim != "Idle") {
        minAnimationDuration = setTimeout(() => setActiveAnim("Idle"), 500)
      }
    }
    return () => {
      clearTimeout(minAnimationDuration)
    }
  }, [scrollDirection])

  const handleClick = (e) => {
    setActiveAnim("Clicked")
    actions.Clicked.setLoop(THREE.LoopOnce)
  }

  return (
    <>
      <group ref={group} {...props} dispose={null}>
        <group name="Scene">
          <group name="Dustin_Rig">
            <primitive object={nodes.Bone} />
            <skinnedMesh
              name="Cylinder003"
              geometry={nodes.Cylinder003.geometry}
              material={materials.Dustin_Mat}
              skeleton={nodes.Cylinder003.skeleton}
            />
            <skinnedMesh
              name="Dustin"
              geometry={nodes.Dustin.geometry}
              material={materials.Dustin_Mat}
              skeleton={nodes.Dustin.skeleton}
              onClick={handleClick}
            />
          </group>
        </group>
      </group>
    </>
  )
}

useGLTF.preload("/character-transformed.glb")
